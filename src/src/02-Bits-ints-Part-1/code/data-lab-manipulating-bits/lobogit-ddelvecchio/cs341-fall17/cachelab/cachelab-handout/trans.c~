/*
 * trans.c
 *
 *  Created on: Dec 1, 2017
 *      Author: Dominic
 */

/*
 * trans.c - Matrix transpose B = A^T
 *
 * Each transpose function must have a prototype of the form:
 * void trans(int M, int N, int A[N][M], int B[M][N]);
 *
 * A transpose function is evaluated by counting the number of misses
 * on a 1KB direct mapped cache with a block size of 32 bytes.
 */
#include <stdio.h>
#include <stdlib.h>
#include "cachelab.h"

int is_transpose(int M, int N, int A[N][M], int B[M][N]);

/*
 * transpose_submit - This is the solution transpose function that you
 *     will be graded on for Part B of the assignment. Do not change
 *     the description string "Transpose submission", as the driver
 *     searches for that string to identify the transpose function to
 *     be graded.
 */
char transpose_submit_desc[] = "Transpose submission";
void transposeIrregular(int M, int N, int A[N][M], int B[M][N])
{

}
void transposeSquare(int size, int M, int N, int A[N][M], int B[M][N])
{
  int block;
  int diagflag = 0;
  if(size == 32)
    {
      block = 8;
    }
  else
    {
      block = 4;
    }
  int i,j,k,l,dindex,temp;

  for(i = 0; i < N; i += block)
    {
      for(j = 0; j < M; j += block)
	{
	  for(k = i; k < i + block; k++)
	    {
	      for(l = j; l < j + block; l++)
		{
		  if(k!=l) B[l][k] = A[k][l];
		  else
		    {
		      temp = A[k][l];
		      dindex = k;
		      diagflag= 1;
		    }

		}
	      if(diagflag == 1)
		{
		  B[dindex][dindex] = temp;
		  diagflag = 0;
		}
	    }
	}
    }

}
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
  switch(M)
    {
    case 32:
      transposeSquare(32,M,N,A,B);
      break;
    case 64:
      transposeSquare(64,M,N,A,B);
      break;
    case 61:
      transposeIrregular(M,N,A,B);
      break;
    default:
      exit(1);
    }

  /*
   * You can define additional transpose functions below. We've defined
   * a simple one below to help you get started.
   */

  /*
   * trans - A simple baseline transpose function, not optimized for the cache.
   */
  char trans_desc[] = "Simple row-wise scan transpose";
  void trans(int M, int N, int A[N][M], int B[M][N])
  {
    int i,j,k,l,s,d,temp;

    for(i = 0; i < N; i += 16)
      {
	for(j = 0; j < M; j += 4)
	  {
	    for(k = i; (k < i+16)&&(k<N); k++)
	      {
		for(l = j; (l < j + 4)&&(l<M); l++)
		  {
		    if(k!=l) B[l][k] = A[k][l];
		    else
		      {
			temp = A[k][l];
			d = k;
			s = 1;
		      }

		  }
		if(s == 1){
		  B[d][d] = temp;
		  s = 0;
		}
	      }
	  }
      }

  }

  /*
   * registerFunctions - This function registers your transpose
   *     functions with the driver.  At runtime, the driver will
   *     evaluate each of the registered functions and summarize their
   *     performance. This is a handy way to experiment with different
   *     transpose strategies.
   */
  void registerFunctions()
  {
    /* Register your solution function */
    registerTransFunction(transpose_submit, transpose_submit_desc);

    /* Register any additional transpose functions */
    registerTransFunction(trans, trans_desc);

  }

  /*
   * is_transpose - This helper function checks if B is the transpose of
   *     A. You can check the correctness of your transpose by calling
   *     it before returning from the transpose function.
   */
  int is_transpose(int M, int N, int A[N][M], int B[M][N])
  {
    int i, j;

    for (i = 0; i < N; i++) {
      for (j = 0; j < M; ++j) {
	if (A[i][j] != B[j][i]) {
	  return 0;
	}
      }
    }
    return 1;
  }


  
